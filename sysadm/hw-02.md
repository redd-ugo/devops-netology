# Домашнее задание по теме "Работа в терминале. Лекция 2"
1. Команда `cd` является встроенной командой 'bash'. Это необходимо для того, чтобы обеспечить быстродействие - нет необходимости запускать дополнительный подпроцесс. Либо для того, чтобы иметь доступ к внутренним структурам `bash`  
Проверить это можно командой `type cd`  

![cd такова](./img/hw02-01.jpg)
2. Заменой конструкции `grep <some_string> <some_file> | wc -l` будет конструкция `grep <some_string> <some_file> -c`  
3. Программой с PID 1 будет `/sbin/init`  
4. Для того, чтобы узнать адрес другой сессии терминала необходимо запустить в нем утилиту `tty`, получим адрес, например `/dev/pts/1`. После этого воспользоваться перенаправлением: `ls ./not_existing_dir 2>/dev/pts/1`  
5. Для этого можно воспользоваться перенаправлениями: `cat <input.txt >example.txt`  
6. Можно воспользоваться перенаправлением вывода команды в соответствующий `/dev/tty?`:  
`cat example.txt > /dev/tty0`  
7. Выполнение команды `bash 5>&1` перенаправит в стандартный поток вывода всю информацию из дескриптора `5`. Если мы выполняем команду `echo netology > /proc/$$/fd/5`, то мы перенаправляем вывод команды `echo` в дескриптор `5` текущего PID благодаря конструкции `$$`. Так как первой командой мы перенаправили весь вывод из этого дескриптора на `stdout`, то в результате мы увидим вывод на экране терминала `netology`.  
8. Получится, для этого мы воспользуемся промежуточным дескриптором 5:  

        $ ls ./no_such_dir  
        ls: невозможно получить доступ к './no_such_dir': Нет такого файла или каталога  
        $ ls ./no_such_dir 5>&1 1>&2 2>&5 | grep Нет  
        ls: невозможно получить доступ к './no_such_dir': Нет такого файла или каталога  
9. Команда `cat /proc/$$/environ` выведет все переменные окружения для запустившего команду процесса (например, нашего терминала). Аналогично можно воспользоваться командой `env`.  
10. По пути `/proc/[pid]/cmdline` содержится read-only файл, содержащий полную комндную строку процесса, если он не является зомби (см. 228 строку `man proc`).  
По пути `/proc/[pid]/exe` начиная с ядра Linux 2.2 содержится символьная ссылка на исполняемый файл, запустивший процесс (см. 294 строку `man proc`).  
11. Самая новая версия набора инструкций, поддерживаемая моим CPU SSE 4.2:  
        $ grep sse /proc/cpuinfo
        flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc pni pclmulqdq ssse3 cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single kaiser fsgsbase avx2 invpcid rdseed clflushopt flush_l1d
12. Для запуска сессии ssh в режиме `tty` можно использовать ключ `-t`:
        ssh -t localhost 'tty'  
13. В одном из терминалов запустил `sleep 500`. После этого:
        $ ^z
        $ bg; disown -a
На другом терминале
        $ ps ax -o pid,cmd | grep sleep
        1938 sleep 500
        $ sudo reptyr -T 1938
14. Команда `tee` копирует стандартный ввод в каждый ФАЙЛ, а также в стандартный вывод. Поэтому, в конструкции `echo string | sudo tee /root/new_file` мы запускаем с повышенными привилегиями `tee`, которая на вход принимает перенаправленный через pipe вывод команды `echo` и обладает достаточными правами для записи в `/root/new_file`. Так же `tee` дублирует входной поток в стандартный поток вывода  

